<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drawing Canvas üé®</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;700&display=swap');
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: "Poppins", sans-serif;
    }
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      background: #141414;
      color: #ffffff;
      overflow: auto;
    }
    @media only screen and (max-width: 400px) {
      #canvas {
        height: 200px;
      }
      .bottombar {
        overflow-x: auto;
        gap: 1px;
      }
      body {
        overflow: auto;
      }
      .shortcutkeys {
        width: 100%;
      }
      #fill, #reset, #undo, #redo, #save, #eraser, #smudge {
        font-size: 10px;
      }
    }
    #canvas {
      border: 2px solid #1fa44b;
      margin: 10px auto;
      width: calc(100% - 20px);
      height: calc(90vh - 50px);
      background: #232323;
      border-radius: 10px;
      touch-action: none;
      display: block;
    }
    .topbar, .bottombar {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
      width: 100%;
      margin-top: 10px;
      overflow-x: auto;
    }
    #favcolor {
      border: none;
      height: 30px;
      width: 30px;
      border-radius: 50%;
      cursor: pointer;
    }
    #favcolor::-webkit-color-swatch-wrapper {
      padding: 0;
      border-radius: 50%;
    }
    #favcolor::-webkit-color-swatch {
      border: none;
      border-radius: 50%;
    }
    #fill, #reset, #undo, #redo, #save, #eraser, #smudge {
      background-color: #555;
      color: #fff;
      border: none;
      padding: 5px 10px;
      cursor: pointer;
      border-radius: 5px;
    }
    #fill:hover, #reset:hover, #undo:hover, #redo:hover, #save:hover, #eraser:hover, #smudge:hover {
      background: #003d3d;
    }
    #fill.active, #eraser.active, #smudge.active {
      background-color: #31a44b;
    }
    label {
      user-select: none;
    }
    .brush {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 8px;
    }
  </style>
</head>
<body>
  <div class="topbar">
    <div class="brush">
      <label>Color:</label>
      <input type="color" id="favcolor" value="#ff0000">
    </div>
    <div class="brush">
      <label>Brush Size:</label>
      <input type="range" min="1" max="30" value="10" id="range">
    </div>
  </div>

  <canvas id="canvas"></canvas>

  <div class="shortcutkeys" id="infobox"
       style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
       background: black; padding: 30px; border-radius: 20px; display: none; width: 60%; text-align: justify;">
    <button onclick="hideInfo()" style="position: absolute; top: 10px; right: 10px; background: none; border: none; color: white; font-size: 20px; cursor: pointer;">&times;</button>
    <h3>Shortcut Keys on Keyboard:</h3>
    <p>
      1 - 9 : Select Brush Size <br>
      w : white, k : black, r : red, g : green, b : blue, c : cyan, m : magenta, y : yellow <br>
      ctrl + z: undo, ctrl + y / ctrl + shift + z: redo <br>
      d: reset canvas<br>
      f: fill<br>
      e: eraser<br>
      s: smudge
    </p>
  </div>

  <div class="bottombar">
    <button id="q" onclick="toggleInfo()">‚ùî</button>
    <button id="undo" onclick="undo()">Undo</button>
    <button id="reset" onclick="resetCanvas()">Reset</button>
    <button id="fill" onclick="toggleFillMode()">Fill</button>
    <button id="eraser" onclick="toggleEraserMode()">Erase</button>
    <button id="smudge" onclick="toggleSmudgeMode()">Blend</button>
    <button id="redo" onclick="redo()">Redo</button>
    <button id="save" onclick="saveCanvas()">Save</button>
  </div>

  <script>
    let canvas, ctx;
    let painting = false;
    let fillMode = false, eraserMode = false, smudgeMode = false;
    let lastX, lastY, startX, startY;
    let history = [], redoStack = [];

    window.addEventListener("load", () => {
      canvas = document.getElementById("canvas");
      ctx = canvas.getContext("2d");

      function resizeCanvas(preserve = true) {
        // Save old drawing
        let savedImage = null;
        if (preserve) {
          savedImage = new Image();
          savedImage.src = canvas.toDataURL();
        }

        // Adjust canvas resolution to CSS
        canvas.width = canvas.offsetWidth;
        canvas.height = canvas.offsetHeight;

        // Restore drawing
        if (preserve && savedImage) {
          savedImage.onload = () => {
            ctx.drawImage(savedImage, 0, 0, canvas.width, canvas.height);
          };
        }
      }

      resizeCanvas(false);

      // Restore from localStorage
      const savedData = localStorage.getItem("drawingCanvas");
      if (savedData) {
        const img = new Image();
        img.src = savedData;
        img.onload = () => ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
      }

      window.addEventListener("resize", () => resizeCanvas(true));

      function saveState() {
        history.push(ctx.getImageData(0, 0, canvas.width, canvas.height));
        redoStack = [];
        saveToLocal();
      }

      function saveToLocal() {
        localStorage.setItem("drawingCanvas", canvas.toDataURL());
      }

      function startPosition(e) {
        e.preventDefault();
        if (!fillMode && (e.button === 0 || e.type === "touchstart")) {
          painting = true;
          const { x, y } = getCursorPosition(e);
          lastX = startX = x;
          lastY = startY = y;
          draw(e);
        }
      }

      function finishPosition() {
        painting = false;
        if (!fillMode) saveState();
        ctx.beginPath();
      }

      function getCursorPosition(e) {
        let x, y;
        if (e.type.startsWith("touch")) {
          const touch = e.touches[0];
          x = touch.clientX - canvas.getBoundingClientRect().left;
          y = touch.clientY - canvas.getBoundingClientRect().top;
        } else {
          x = e.offsetX;
          y = e.offsetY;
        }
        return { x, y };
      }

      function draw(e) {
        if (!painting || fillMode || smudgeMode) return;

        const { x, y } = getCursorPosition(e);
        ctx.lineWidth = document.getElementById("range").value;
        ctx.lineCap = "round";

        if (eraserMode) {
          ctx.globalCompositeOperation = "destination-out";
          ctx.strokeStyle = "rgba(0,0,0,1)";
        } else {
          ctx.globalCompositeOperation = "source-over";
          ctx.strokeStyle = document.getElementById("favcolor").value;
        }

        ctx.beginPath();
        ctx.moveTo(lastX, lastY);
        ctx.lineTo(x, y);
        ctx.stroke();

        lastX = x;
        lastY = y;
      }

      function undo() {
        if (history.length > 1) {
          redoStack.push(history.pop());
          ctx.putImageData(history[history.length - 1], 0, 0);
          saveToLocal();
        }
      }

      function redo() {
        if (redoStack.length > 0) {
          const imageData = redoStack.pop();
          history.push(imageData);
          ctx.putImageData(imageData, 0, 0);
          saveToLocal();
        }
      }

      function resetCanvas() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);
        saveState();
      }

      function saveCanvas() {
        const link = document.createElement("a");
        link.download = "canvas_drawing.png";
        link.href = canvas.toDataURL("image/png");
        link.click();
      }

      // Attach listeners
      canvas.addEventListener("mousedown", startPosition);
      canvas.addEventListener("mouseup", finishPosition);
      canvas.addEventListener("mousemove", draw);

      canvas.addEventListener("touchstart", startPosition);
      canvas.addEventListener("touchend", finishPosition);
      canvas.addEventListener("touchmove", draw);

      window.undo = undo;
      window.redo = redo;
      window.resetCanvas = resetCanvas;
      window.saveCanvas = saveCanvas;

      saveState();
    });

    function toggleInfo() {
      const infobox = document.getElementById("infobox");
      infobox.style.display = infobox.style.display === "none" ? "block" : "none";
    }
    function hideInfo() {
      document.getElementById("infobox").style.display = "none";
    }

    function toggleFillMode() {}
    function toggleEraserMode() { eraserMode = !eraserMode; }
    function toggleSmudgeMode() { smudgeMode = !smudgeMode; }
  </script>
</body>
</html>
